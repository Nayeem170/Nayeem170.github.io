<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Robust API Rate Limiting System for Multi-Tenant E-Commerce Platform</title>
    <link rel="stylesheet" href="blog-post-styles.css">
    <script src="../data.js"></script>
    <script src="posts-data.js"></script>
    <script src="blog-post.js"></script>
</head>

<body>
    <div class="container">
        <div class="metadata">
            <p><strong>Published:</strong> <span id="post-date"></span></p>
            <p><strong>Category:</strong> <span id="post-category"></span></p>
            <p><strong>Tags:</strong> <span id="post-tags"></span></p>
            <p><strong>Reading Time:</strong> <span id="post-reading-time"></span></p>
        </div>

        <h1>Building a Robust API Rate Limiting System for Multi-Tenant E-Commerce Platform</h1>

        <p>We've built a multi-tenant e-commerce platform that serves hundreds of customers across multiple storefronts.
            As our API usage grew, we faced a critical challenge: how do we protect our resources from abuse while
            ensuring fair access for all our tenants?</p>

        <p>In this post, I'll walk you through how we designed and implemented a comprehensive API rate limiting system
            that balances security, performance, and developer experience.</p>

        <h2>üéØ The Problem We Needed to Solve</h2>

        <p>When we launched our platform, we quickly encountered several issues:</p>

        <ul>
            <li><strong>API Abuse:</strong> Some tenants were making excessive requests, impacting server performance
            </li>
            <li><strong>Unfair Resource Allocation:</strong> Heavy users were consuming resources meant for all tenants
            </li>
            <li><strong>Operational Concerns:</strong> No visibility into API usage patterns or ability to control it
            </li>
            <li><strong>Scalability Challenges:</strong> As we added more tenants, problem intensified</li>
        </ul>

        <p>We needed a solution that was:</p>

        <div class="feature-list">
            <div class="feature-item">
                <h4>üîí Secure</h4>
                <p>Prevent abuse while allowing legitimate traffic</p>
            </div>
            <div class="feature-item">
                <h4>‚ö° Performant</h4>
                <p>Minimal impact on API response times</p>
            </div>
            <div class="feature-item">
                <h4>üéõÔ∏è Configurable</h4>
                <p>Flexible limits per tenant and API key</p>
            </div>
        </div>

        <h2>üèóÔ∏è Architecture Overview</h2>

        <p>Our rate limiting implementation follows a <strong>middleware-based approach</strong> that intercepts every
            request before it reaches our controllers. Here's how it fits into our pipeline:</p>

        <div class="flow-diagram">
            <h3 class="pipeline-title">Middleware Pipeline</h3>

            <div class="flow-step">
                <div class="flow-number">1</div>
                <div class="flow-box">HTTPS Redirection</div>
                <div class="flow-desc">Redirects HTTP to HTTPS</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">2</div>
                <div class="flow-box">Static Files</div>
                <div class="flow-desc">Serves static assets</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">3</div>
                <div class="flow-box">CORS</div>
                <div class="flow-desc">Handles cross-origin requests</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">4</div>
                <div class="flow-box">Routing</div>
                <div class="flow-desc">Matches URLs to routes</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">5</div>
                <div class="flow-box">Tenant Resolution</div>
                <div class="flow-desc">Identifies tenant from domain</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">6</div>
                <div class="flow-box">API Key Auth Middleware</div>
                <div class="flow-desc">Validates API keys</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">7</div>
                <div class="flow-box">Authentication (Firebase)</div>
                <div class="flow-desc">Validates Firebase tokens</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">8</div>
                <div class="flow-box">Authorization</div>
                <div class="flow-desc">Checks permissions</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">9</div>
                <div class="flow-box">Domain Enforcement</div>
                <div class="flow-desc">Validates tenant domain</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">10</div>
                <div class="flow-box flow-highlight">üî• RATE LIMITING</div>
                <div class="flow-desc">Enforces rate limits ‚Üê Our Implementation</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">11</div>
                <div class="flow-box">Options Short Circuit</div>
                <div class="flow-desc">Handles OPTIONS requests</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">12</div>
                <div class="flow-box">Swagger</div>
                <div class="flow-desc">API documentation</div>
                <div class="flow-arrow">‚Üì</div>
            </div>

            <div class="flow-step">
                <div class="flow-number">13</div>
                <div class="flow-box">Controllers</div>
                <div class="flow-desc">Executes endpoint logic</div>
            </div>
        </div>

        <div class="alert alert-info">
            <strong>Key Design Decision:</strong> Rate limiting runs AFTER authentication but BEFORE controllers,
            ensuring only authenticated requests are tracked while maintaining maximum performance.
        </div>

        <h2>üîê API Key-Based Rate Limiting</h2>

        <p>After evaluating multiple approaches, we chose <strong>API key-based rate limiting</strong> as our primary
            strategy. Here's why:</p>

        <ul>
            <li><strong>Precise Control:</strong> Each tenant can have multiple API keys with different limits</li>
            <li><strong>Granular Limits:</strong> Read vs write operations have separate rate limits</li>
            <li><strong>Database-Backed:</strong> Limits are stored in DynamoDB, easily adjustable without restarts</li>
            <li><strong>Multi-Tenant Support:</strong> Complete isolation between tenants</li>
        </ul>

        <h3>How It Works</h3>

        <p>Every request must include an API key in the <code>X-API-Key</code> header. Our middleware:</p>

        <ol>
            <li>Extracts the API key from the request headers</li>
            <li>Verifies it exists in the tenant database</li>
            <li>Loads the API key's specific rate limits</li>
            <li>Tracks request count in a 1-minute sliding window</li>
            <li>Allows or blocks based on the limit</li>
        </ol>

        <h3>Rate Limiting Flow</h3>
        <div class="flow-diagram">
            <div class="flow-step">
                <div class="flow-number">1</div>
                <div class="flow-box">Request Arrives</div>
                <div class="flow-arrow">‚Üì</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">2</div>
                <div class="flow-box">Extract API Key from X-API-Key header</div>
                <div class="flow-arrow">‚Üì</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">3</div>
                <div class="flow-box">Verify API Key in Tenant Database</div>
                <div class="flow-branch-container">
                    <div class="flow-branch">
                        <div class="flow-branch-item flow-error">‚ùå API Key Not Found ‚Üí Return 429 Too Many Requests
                        </div>
                    </div>
                    <div class="flow-branch">
                        <div class="flow-branch-item flow-error">‚ùå API Key Inactive ‚Üí Return 429 Too Many Requests</div>
                    </div>
                    <div class="flow-branch">
                        <div class="flow-branch-item flow-success">‚úì API Key Valid ‚Üí Continue</div>
                        <div class="flow-arrow">‚Üì</div>
                    </div>
                </div>
            </div>
            <div class="flow-step">
                <div class="flow-number">4</div>
                <div class="flow-box">Load Rate Limits (Read/Write per min)</div>
                <div class="flow-arrow">‚Üì</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">5</div>
                <div class="flow-box">Check Sliding Window (Last 1 minute)</div>
                <div class="flow-branch-container">
                    <div class="flow-branch">
                        <div class="flow-branch-item flow-error">‚ùå Over Limit ‚Üí Return 429 Too Many Requests</div>
                    </div>
                    <div class="flow-branch">
                        <div class="flow-branch-item flow-success">‚úì Within Limit ‚Üí Continue</div>
                        <div class="flow-arrow">‚Üì</div>
                    </div>
                </div>
            </div>
            <div class="flow-step">
                <div class="flow-number">6</div>
                <div class="flow-box">Increment Counter & Add Response Headers</div>
                <div class="flow-arrow">‚Üì</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">7</div>
                <div class="flow-box flow-success">‚úÖ Process Request Successfully</div>
            </div>
        </div>

        <h2>üìä Sliding Window Algorithm</h2>

        <p>We implemented a <strong>1-minute sliding window</strong> algorithm for accurate rate limiting. Here's how it
            works:</p>

        <div class="simple-window-container">
            <div class="simple-window-box">
                <div class="simple-window-title">1-Minute Window</div>
                <div class="simple-window-content">
                    <p>Tracks requests made in the last <span class="rate-limit-value">60</span> seconds</p>
                    <p>Current window: <span class="rate-limit-value">60</span> requests (at limit)</p>
                </div>
            </div>

            <div class="simple-divider">‚Üì New Request Arrives</div>

            <div class="simple-window-box rejected-window">
                <div class="simple-window-title">Request #<span class="rate-limit-value">61</span></div>
                <div class="simple-window-content">
                    <p>‚ùå <strong>REJECTED</strong></p>
                    <p>Window already has <span class="rate-limit-value">60</span> requests</p>
                </div>
            </div>
        </div>

        <div class="simple-explanation">
            <h3>How It Works</h3>
            <ol>
                <li>Each request is tracked with its timestamp</li>
                <li>Only requests from the last <span class="rate-limit-value">60</span> seconds are counted</li>
                <li>When the limit is reached, new requests are rejected</li>
                <li>Requests older than <span class="rate-limit-value">60</span> seconds automatically expire</li>
                <li>The window continuously slides forward, counting only recent requests</li>
            </ol>
        </div>

        <h3>Implementation Details</h3>

        <p>We track request timestamps in an in-memory list and continuously clean up old timestamps:</p>

        <pre><code>// Check if request is within rate limit
public bool IsWithinLimit(RateLimitConfig config)
{
    var now = DateTime.UtcNow;
    
    // Cleanup timestamps older than 1 minute
    var cutoffTime = now.AddMinutes(-1);
    _requestTimestamps.RemoveAll(timestamp => timestamp < cutoffTime);
    
    // Check if we're within the limit
    if (_requestTimestamps.Count >= config.ReadRequestsPerMinute)
    {
        return false; // Rate limit exceeded
    }

    // Add current request timestamp
    _requestTimestamps.Add(now);
    return true;
}</code></pre>

        <div class="alert alert-success">
            <strong>Benefits:</strong> This approach provides smooth, accurate rate limiting without sudden bursts or
            unfair resets.
        </div>

        <h2>üîÄ Read vs Write Operations</h2>

        <p>We differentiate between read and write operations, applying different rate limits:</p>

        <div class="read-section">
            <div class="section-header">
                <div class="section-icon">üìñ</div>
                <div class="section-title">Read Operations</div>
                <div class="section-limit"><span class="rate-limit-value">60 requests/minute</span></div>
            </div>
            <div class="section-content">
                <p><strong>HTTP Method:</strong> GET</p>
                <p><strong>Limit:</strong> <span class="rate-limit-value">60</span> requests per minute</p>
                <p><strong>Reason:</strong> Read operations are less resource-intensive and don't modify data</p>
            </div>
        </div>

        <div class="write-section">
            <div class="section-header">
                <div class="section-icon">‚úèÔ∏è</div>
                <div class="section-title">Write Operations</div>
                <div class="section-limit"><span class="rate-limit-value">10 requests/minute</span></div>
            </div>
            <div class="section-content">
                <p><strong>HTTP Methods:</strong> POST, PUT, PATCH, DELETE</p>
                <p><strong>Limit:</strong> <span class="rate-limit-value">10</span> requests per minute</p>
                <p><strong>Reasons:</strong></p>
                <ul>
                    <li>Prevent data corruption from excessive writes</li>
                    <li>Block spam submissions</li>
                    <li>Avoid excessive updates to data</li>
                    <li>Protect against mass deletions</li>
                </ul>
            </div>
        </div>

        <h2>üíæ Database-Backed Configuration</h2>

        <p>Rate limits are stored in DynamoDB, allowing real-time updates without application restarts:</p>

        <pre><code>{
  "TenantId": "aae917efdde94c5f8094f0a9fff3aa61",
  "TenantName": "example-store",
  "ApiKeys": [
    {
      "Key": "production-client-123",
      "Name": "Production App",
      "IsActive": true,
      "CreatedAt": "2024-01-15T10:30:00Z",
      "RateLimits": {
        "ReadRequestsPerMinute": 120,
        "WriteRequestsPerMinute": 20
      }
    },
    {
      "Key": "development-client-456",
      "Name": "Development App",
      "IsActive": true,
      "CreatedAt": "2024-01-20T14:45:00Z",
      "RateLimits": {
        "ReadRequestsPerMinute": 60,
        "WriteRequestsPerMinute": 10
      }
    }
  ]
}</code></pre>

        <div class="alert alert-info">
            <strong>Flexible Configuration:</strong> Each tenant can have multiple API keys with custom limits, allowing
            granular control over different applications and use cases.
        </div>

        <h2>üîÑ Memory Management & Cleanup</h2>

        <p>To prevent memory leaks, we automatically clean up stale request data:</p>

        <div class="diagram">
            <div class="memory-counter-box">
                <div class="memory-counter-title">In-Memory Rate Limit Counters</div>
            </div>

            <div class="code-block">
                <pre><code>ConcurrentDictionary<string, EnhancedRateLimitCounter> _counters</code></pre>
            </div>

            <div class="section-label">Counter Key Format: "METHOD:PATH:API_KEY"</div>
            <div class="examples-list">
                <div class="example-item">- "GET:/api/products:apikey123"</div>
                <div class="example-item">- "POST:/api/orders:apikey456"</div>
                <div class="example-item">- "DELETE:/api/products/123:apikey789"</div>
            </div>

            <div class="cleanup-section">
                <div class="cleanup-title">Cleanup Task (runs every 5 minutes):</div>
                <div class="cleanup-steps">
                    <div class="cleanup-step">1. Scan all counters</div>
                    <div class="cleanup-step">2. Remove counters inactive for 5+ minutes</div>
                    <div class="cleanup-step">3. Free memory</div>
                    <div class="cleanup-step">4. Log cleanup statistics</div>
                </div>
            </div>

            <div class="example-section">
                <div class="example-title">Example:</div>
                <div class="example-data">
                    <div class="example-row">Initial: 10,000 counters</div>
                    <div class="example-row">After cleanup: 2,500 active counters</div>
                    <div class="example-row highlight">Memory saved: 75%</div>
                </div>
            </div>
        </div>

        <pre><code>// Automatic cleanup task
private async Task CleanupExpiredCounters()
{
    while (true)
    {
        await Task.Delay(TimeSpan.FromMinutes(5));
        
        var expiredKeys = new List<string>();
        var now = DateTime.UtcNow;
        
        // Find counters that haven't been used for 5 minutes
        foreach (var kvp in _counters)
        {
            if (kvp.Value.IsExpired(now))
            {
                expiredKeys.Add(kvp.Key);
            }
        }
        
        // Remove expired counters
        foreach (var key in expiredKeys)
        {
            _counters.TryRemove(key, out _);
        }
        
        if (expiredKeys.Count > 0)
        {
            _logger.LogDebug("Cleaned up {Count} expired rate limit counters", 
                expiredKeys.Count);
        }
    }
}</code></pre>

        <h2>üì° Response Headers</h2>

        <p>We provide informative response headers to help developers monitor their API usage:</p>

        <pre><code>HTTP/1.1 200 OK
Content-Type: application/json
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 59
X-RateLimit-Reset: 1704303600</code></pre>

        <table>
            <tr>
                <th>Header</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            <tr>
                <td><code>X-RateLimit-Limit</code></td>
                <td>The rate limit for this API key</td>
                <td><code>60</code></td>
            </tr>
            <tr>
                <td><code>X-RateLimit-Remaining</code></td>
                <td>Requests remaining in current minute</td>
                <td><code>59</code></td>
            </tr>
            <tr>
                <td><code>Retry-After</code></td>
                <td>Seconds to wait before retry (429 only)</td>
                <td><code>60</code></td>
            </tr>
        </table>

        <h2>üö® Error Handling</h2>

        <p>When rate limits are exceeded, we return clear, actionable error messages:</p>

        <pre><code>HTTP/1.1 429 Too Many Requests
Retry-After: 60
Content-Type: application/json

{
  "error": "Rate limit exceeded",
  "message": "Too many requests.",
  "identifier": "apikey:production***123",
  "identifierType": "API Key",
  "retryAfter": 60
}</code></pre>

        <div class="alert">
            <strong>Note:</strong> We use a fail-open strategy - if rate limiting encounters an error, the request is
            allowed to continue to prevent application downtime.
        </div>

        <h2>Performance Optimizations</h2>

        <ul>
            <li><strong>In-Memory Storage:</strong> <code>ConcurrentDictionary</code> provides thread-safe O(1) lookups
                with minimal contention</li>
            <li><strong>Efficient Cleanup:</strong> Automatic cleanup of stale counters every 5 minutes prevents memory
                leaks</li>
            <li><strong>Minimal Database Calls:</strong> API keys cached in memory after first verification, reducing DB
                load</li>
            <li><strong>Asynchronous Operations:</strong> Non-blocking cleanup task runs in background for better
                throughput</li>
            <li><strong>Concurrent Processing:</strong> Supports multiple concurrent connections without degradation
            </li>
        </ul>

        <h2>üéØ Key Features Summary</h2>

        <div class="feature-list">
            <div class="feature-item">
                <h4>üîê API Key Based</h4>
                <p>Precise control per API key and tenant</p>
            </div>
            <div class="feature-item">
                <h4>üìä Read/Write Separation</h4>
                <p>Different limits for read vs write operations</p>
            </div>
            <div class="feature-item">
                <h4>üéöÔ∏è Sliding Window</h4>
                <p>Accurate 1-minute window algorithm</p>
            </div>
            <div class="feature-item">
                <h4>üíæ Database Backed</h4>
                <p>Real-time configuration without restarts</p>
            </div>
            <div class="feature-item">
                <h4>üîç Observable</h4>
                <p>Clear headers and logging for monitoring</p>
            </div>
            <div class="feature-item">
                <h4>‚ö° High Performance</h4>
                <p>Minimal overhead with in-memory storage</p>
            </div>
            <div class="feature-item">
                <h4>üîÑ Auto Cleanup</h4>
                <p>Automatic memory management</p>
            </div>
            <div class="feature-item">
                <h4>üõ°Ô∏è Fail-Open</h4>
                <p>Requests allowed if rate limiting fails</p>
            </div>
        </div>

        <h2>üìù Management API</h2>

        <p>We provide a comprehensive API for managing rate limits:</p>

        <h3>Get Rate Limit Status</h3>

        <pre><code>GET /api/rate-limit/status/{apiKey}
Authorization: Bearer <firebase_jwt_token>

Response:
{
  "success": true,
  "apiKey": "production-client-123",
  "tenantId": "aae917efdde94c5f8094f0a9fff3aa61",
  "rateLimit": {
    "readRequestsPerMinute": 60,
    "writeRequestsPerMinute": 10
  }
}</code></pre>

        <h3>Update Rate Limits</h3>

        <pre><code>POST /api/rate-limit/set
Authorization: Bearer <firebase_jwt_token>
Content-Type: application/json

{
  "apiKey": "production-client-123",
  "tenantId": "aae917efdde94c5f8094f0a9fff3aa61",
  "readRequestsPerMinute": 60,
  "writeRequestsPerMinute": 10
}</code></pre>

        <h3>Reset Rate Limits</h3>

        <pre><code>POST /api/rate-limit/reset
Authorization: Bearer <firebase_jwt_token>
Content-Type: application/json

{
  "apiKey": "production-client-123",
  "tenantId": "aae917efdde94c5f8094f0a9fff3aa61"
}</code></pre>

        <h2>üéì Design Decisions & Trade-offs</h2>

        <h3>Why API Key-Based Rate Limiting Over Other Approaches?</h3>

        <p>We evaluated several rate limiting approaches before implementing our solution. Here's a comprehensive
            comparison of why API key-based rate limiting was the right choice for our platform:</p>

        <table>
            <tr>
                <th>Approach</th>
                <th>Pros</th>
                <th>Cons</th>
                <th>Our Decision</th>
            </tr>
            <tr>
                <td><strong>IP-Based</strong></td>
                <td>‚Ä¢ Simple to implement<br>‚Ä¢ No authentication needed<br>‚Ä¢ Works for anonymous users</td>
                <td>‚Ä¢ Shared IP (NAT, CDN, proxy) blocks legitimate users<br>‚Ä¢ IP spoofing possible<br>‚Ä¢ Mobile devices
                    change IPs<br>‚Ä¢ Cannot distinguish between different applications<br>‚Ä¢ Fairness issues (office vs
                    individual)</td>
                <td style="color: #e74c3c; font-weight: bold;">‚ùå Rejected</td>
            </tr>
            <tr>
                <td><strong>User-Based</strong></td>
                <td>‚Ä¢ Fair per-user limits<br>‚Ä¢ Works with Firebase auth<br>‚Ä¢ Consistent across devices</td>
                <td>‚Ä¢ Requires authentication for every request<br>‚Ä¢ No support for machine-to-machine API calls<br>‚Ä¢
                    Cannot differentiate between user's apps<br>‚Ä¢ Single user with multiple apps hits one limit</td>
                <td style="color: #e74c3c; font-weight: bold;">‚ùå Rejected</td>
            </tr>
            <tr>
                <td><strong>IP + User Hybrid</strong></td>
                <td>‚Ä¢ Covers both authenticated and anonymous<br>‚Ä¢ More flexible than single approach</td>
                <td>‚Ä¢ Complex to implement<br>‚Ä¢ Inconsistent experience<br>‚Ä¢ IP limitations still apply<br>‚Ä¢ Hard to
                    debug issues</td>
                <td style="color: #e74c3c; font-weight: bold;">‚ùå Rejected</td>
            </tr>
            <tr>
                <td><strong>Token-Based (JWT)</strong></td>
                <td>‚Ä¢ Tied to authentication<br>‚Ä¢ Stateless<br>‚Ä¢ Works with our Firebase auth</td>
                <td>‚Ä¢ Tokens have expiration<br>‚Ä¢ Rate limit resets on token refresh<br>‚Ä¢ Cannot track long-term
                    usage<br>‚Ä¢ No visibility into API usage patterns</td>
                <td style="color: #e74c3c; font-weight: bold;">‚ùå Rejected</td>
            </tr>
            <tr>
                <td><strong>API Key-Based</strong></td>
                <td>‚Ä¢ Precise per-application control<br>‚Ä¢ Supports M2M (machine-to-machine) communication<br>‚Ä¢
                    Persistent across sessions<br>‚Ä¢ Easy to rotate/manage<br>‚Ä¢ Clear separation of concerns<br>‚Ä¢ Works
                    for both authenticated and unauthenticated scenarios<br>‚Ä¢ Database-backed for real-time
                    configuration</td>
                <td>‚Ä¢ Requires API key management<br>‚Ä¢ Key rotation overhead<br>‚Ä¢ Security if keys are leaked<br>‚Ä¢ No
                    rate limiting for pure Firebase users (acceptable trade-off)</td>
                <td style="color: #27ae60; font-weight: bold;">‚úÖ CHOSEN</td>
            </tr>
        </table>

        <h3>What We Gained with API Key-Based Approach</h3>

        <div class="feature-list">
            <div class="feature-item">
                <h4>üéØ Application-Level Granularity</h4>
                <p>Each tenant can have multiple API keys for different applications (mobile app, web app, integration)
                    with separate limits</p>
            </div>
            <div class="feature-item">
                <h4>üîÑ Machine-to-Machine Support</h4>
                <p>Perfect for integrations, bots, and automated systems that don't have user authentication</p>
            </div>
            <div class="feature-item">
                <h4>üìä Real-Time Configuration</h4>
                <p>Database-backed storage allows instant limit changes without restarts or deployments</p>
            </div>
            <div class="feature-item">
                <h4>üîê Multi-Tenant Isolation</h4>
                <p>Complete separation between tenants - one tenant's usage doesn't affect another's limits</p>
            </div>
            <div class="feature-item">
                <h4>üìà Better Observability</h4>
                <p>Clear visibility into which applications are using which API keys and how much</p>
            </div>
            <div class="feature-item">
                <h4>üéõÔ∏è Flexible Limits</h4>
                <p>Different read/write limits per API key allows fine-tuned control based on application needs</p>
            </div>
        </div>

        <h3>What We Lost (Trade-offs)</h3>

        <div class="alert">
            <strong>Important:</strong> Every design decision has trade-offs. Here's what we accepted:
        </div>

        <table>
            <tr>
                <th>Trade-off</th>
                <th>Impact</th>
                <th>Why It's Acceptable</th>
            </tr>
            <tr>
                <td><strong>Firebase Users Not Rate Limited</strong></td>
                <td>Users authenticated only with Firebase tokens bypass rate limiting</td>
                <td>Firebase users are typically end-users using web/mobile UI, not programmatic access. Rate limiting
                    is more critical for API keys used by automated systems. Additionally, Firebase tokens have their
                    own security measures.</td>
            </tr>
            <tr>
                <td><strong>API Key Management Overhead</strong></td>
                <td>Requires API key creation, rotation, and deactivation processes</td>
                <td>One-time setup cost. Built comprehensive management API for CRUD operations. Benefits far outweigh
                    this initial setup effort.</td>
            </tr>
            <tr>
                <td><strong>Security if Keys Leaked</strong></td>
                <td>Compromised API key can be used until discovered</td>
                <td>Mitigated by: API key deactivation, rate limit monitoring, IP restrictions (future), and audit
                    logging. Similar risk to any credential-based system.</td>
            </tr>
            <tr>
                <td><strong>Anonymous Requests Blocked</strong></td>
                <td>Requests without API key are rejected with 429</td>
                <td>Intentional design. Forces legitimate API users to obtain proper API keys, enabling tracking and
                    fair resource allocation.</td>
            </tr>
        </table>

        <h3>Why These Trade-offs Were Worth It</h3>

        <ul>
            <li><strong>Multi-tenant Architecture:</strong> API keys map perfectly to our multi-tenant design where each
                tenant needs isolated resources and policies</li>
            <li><strong>B2B Focus:</strong> Most of our API consumers are businesses using integrations, not individual
                end-users. API keys are standard for B2B APIs</li>
            <li><strong>Scalability:</strong> In-memory API key verification (after first check) is extremely fast -
                O(1) lookup with minimal overhead</li>
            <li><strong>Flexibility:</strong> Different limits for read vs write operations prevent abusive writes while
                allowing reasonable read access</li>
            <li><strong>Developer Experience:</strong> Clear headers, predictable behavior, and comprehensive management
                API make it easy for developers to work with</li>
        </ul>

        <div class="alert alert-success">
            <strong>Bottom Line:</strong> API key-based rate limiting provides the best balance of security,
            performance, flexibility, and developer experience for our multi-tenant e-commerce platform. The trade-offs
            are manageable with proper processes and infrastructure, while the benefits directly address our core
            business requirements.
        </div>

        <h2>üöÄ Future Improvements</h2>

        <p>We're exploring several enhancements to our rate limiting system:</p>

        <ul>
            <li><strong>Distributed Rate Limiting:</strong> Using Redis for horizontal scaling</li>
            <li><strong>Adaptive Limits:</strong> Dynamic adjustment based on server load</li>
            <li><strong>Granular Endpoints:</strong> Different limits per API endpoint</li>
            <li><strong>Analytics Dashboard:</strong> Real-time monitoring and alerting</li>
            <li><strong>Burst Allowance:</strong> Short bursts for legitimate traffic spikes</li>
        </ul>

        <h2>‚úÖ Conclusion</h2>

        <p>Implementing API rate limiting has been a game-changer for our platform. We've successfully:</p>

        <ul>
            <li>‚úÖ Eliminated API abuse and excessive traffic</li>
            <li>‚úÖ Ensured fair resource allocation across tenants</li>
            <li>‚úÖ Improved overall system stability and performance</li>
            <li>‚úÖ Provided visibility and control over API usage</li>
            <li>‚úÖ Maintained excellent developer experience with clear feedback</li>
        </ul>

        <p>The system is production-ready, battle-tested, and serving millions of requests daily. If you're building an
            API that needs rate limiting, we hope our experience and implementation details help you on your journey!
        </p>

        <div class="reference-section">
            <h2>üìö References</h2>
            <ul class="reference-list">
                <li><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/" target="_blank"
                        rel="noopener noreferrer">Microsoft Learn: ASP.NET Core Middleware</a></li>
                <li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2"
                        target="_blank" rel="noopener noreferrer">Microsoft Learn: ConcurrentDictionary Class</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429" target="_blank"
                        rel="noopener noreferrer">MDN Web Docs: HTTP 429 Too Many Requests</a></li>
                <li><a href="https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/" target="_blank"
                        rel="noopener noreferrer">Microsoft Learn: Thread-Safe Collections</a></li>
            </ul>
        </div>

        <a href="index.html" class="back-to-home">‚Üê Back to Posts</a>

        <div class="footer">
            <p id="footer-copyright"></p>
        </div>
    </div>
    </div>
</body>

</html>